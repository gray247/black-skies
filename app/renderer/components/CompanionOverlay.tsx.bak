import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import type { LoadedProject, SceneDraftMetadata } from '../../shared/ipc/projectLoader';
import {
  computeEmotionArc,
  computePacingProfile,
  resolveAnalyticsConfig,
} from '../utils/analytics';
import type { EmotionArcPoint, ScenePacingMetric } from '../utils/analytics';
import type { AnalyticsScenes, AnalyticsSummary, SceneMetric } from '../../shared/ipc/services';
import type { ServiceStatus } from './ServiceStatusPill';
import { recordDebugEvent } from '../utils/debugLog';

const RUBRIC_PATTERN = /^[A-Za-z0-9 ,.&:/'-]+$/;
const MAX_RUBRIC_LENGTH = 40;

interface CompanionOverlayProps {
  open: boolean;
  onClose: () => void;
  activeScene: { id: string; title: string | null } | null;
  activeDraft: string;
  project: LoadedProject | null;
  drafts: Record<string, string>;
  rubric: string[];
  onRubricChange: (next: string[]) => void;
  builtInRubric: readonly string[];
  scenes: SceneDraftMetadata[];
  activeSceneId: string | null;
  batchState: BatchCritiqueState;
  onBatchCritique: (sceneIds: string[]) => void | Promise<void>;
  serviceStatus: ServiceStatus;
}

interface SceneInsight {
  label: string;
  value: string;
}

interface DraftAnalysis {
  wordCount: number;
  sentenceAverage: number;
  longestSentenceLength: number;
  longestSentence: string;
  paragraphCount: number;
}

type BatchCritiqueStatus = 'idle' | 'running' | 'success' | 'error';

interface BatchCritiqueSceneResult {
  status: BatchCritiqueStatus;
  summary?: string;
  error?: string;
  traceId?: string;
}

interface BatchCritiqueState {
  running: boolean;
  results: Record<string, BatchCritiqueSceneResult>;
}

interface ModelInsight {
  id: string;
  title: string;
  detail: string;
}

function normaliseWhitespace(text: string): string {
  return text.replace(/\r\n/g, '\n');
}

function sentenceSegments(text: string): string[] {
  const cleaned = normaliseWhitespace(text).trim();
  if (!cleaned) {
    return [];
  }
  return cleaned
    .split(/[.!?]+/u)
    .map((segment) => segment.trim())
    .filter((segment) => segment.length > 0);
}

function analyseDraft(text: string): DraftAnalysis {
  const paragraphs = normaliseWhitespace(text)
    .split(/\n{2,}/)
    .map((item) => item.trim())
    .filter((item) => item.length > 0);

  const sentences = sentenceSegments(text);
  const sentenceLengths = sentences.map((segment) => segment.split(/\s+/).filter(Boolean).length);
  const wordTokens = normaliseWhitespace(text).split(/\s+/).filter(Boolean);
  const longestSentenceLength = sentenceLengths.length
    ? Math.max(...sentenceLengths)
    : 0;
  const longestSentenceIndex = sentenceLengths.indexOf(longestSentenceLength);

  return {
    wordCount: wordTokens.length,
    sentenceAverage:
      sentenceLengths.length > 0
        ? sentenceLengths.reduce((total, length) => total + length, 0) / sentenceLengths.length
        : 0,
    longestSentenceLength,
    longestSentence: longestSentenceIndex >= 0 ? sentences[longestSentenceIndex] ?? '' : '',
    paragraphCount: paragraphs.length,
  };
}

function buildInsights(
  analysis: DraftAnalysis,
  scene: SceneDraftMetadata | null,
  draftEmpty: boolean,
): string[] {
  if (draftEmpty) {
    return ['Draft has no content yet. Add a few sentences to unlock pacing guidance.'];
  }

  const suggestions: string[] = [];
  if (analysis.wordCount < 150) {
    suggestions.push('Scene is lean. Consider expanding sensory detail or internal beats.');
  } else if (analysis.wordCount > 900) {
    suggestions.push('Scene is lengthy. Check for places to tighten or split the momentum.');
  }

  if (analysis.sentenceAverage > 24) {
    suggestions.push('Average sentence length is high; introduce shorter beats to restore pacing.');
  } else if (analysis.sentenceAverage > 0 && analysis.sentenceAverage < 9) {
    suggestions.push('Sentences are very short. Weave in longer lines to vary rhythm.');
  }

  if (scene?.word_target && analysis.wordCount < scene.word_target * 0.7) {
    suggestions.push('Draft is below the planned word target. Flesh out missing beats.');
  } else if (scene?.word_target && analysis.wordCount > scene.word_target * 1.3) {
    suggestions.push('Draft exceeds the planned word target. Trim or redistribute content.');
  }

  if (!scene?.emotion_tag) {
    suggestions.push('No emotion tag set. Add one to highlight the intended tone for critiques.');
  }

  return suggestions;
}

function buildModelInsights(
  analysis: DraftAnalysis,
  scene: SceneDraftMetadata | null,
): ModelInsight[] {
  const toneDescriptor =
    analysis.sentenceAverage > 24
      ? 'Measured'
      : analysis.sentenceAverage < 12
      ? 'Airy'
      : 'Balanced';
  const pacingDescriptor =
    analysis.wordCount > 700 ? 'Expansive' : analysis.wordCount < 250 ? 'Compact' : 'Steady';
  const symbolismDetail = scene?.emotion_tag
    ? `Symbolism echoes the ${scene.emotion_tag} cue.`
    : 'Symbolism cues are sparse; tag the mood to help the model.';
  const rewriteDetail = scene?.purpose
    ? `Model can reshape the scene to highlight the ${scene.purpose} aim.`
    : 'Model can help crystallize the scene purpose for clearer stakes.';

  return [
    {
      id: 'tone-balance',
      title: 'Tone Balance',
      detail: `Model insights note a ${toneDescriptor.toLowerCase()} cadence across the scene.`,
    },
    {
      id: 'pacing-critique',
      title: 'Pacing Critique',
      detail: `Model suggests the pacing feels ${pacingDescriptor.toLowerCase()} for the current beats.`,
    },
    {
      id: 'symbolism-scan',
      title: 'Symbolism Scan',
      detail: symbolismDetail,
    },
    {
      id: 'style-rewrite',
      title: 'Style Rewrite Prompt',
      detail: rewriteDetail,
    },
  ];
}

function statusLabel(status: BatchCritiqueStatus): string {
  switch (status) {
    case 'running':
      return 'Running';
    case 'success':
      return 'Complete';
    case 'error':
      return 'Failed';
    default:
      return 'Ready';
  }
}

function formatIntensity(value: number): string {
  if (!Number.isFinite(value)) {
    return '0.00';
  }
  return value.toFixed(2);
}

interface InsightsAnalyticsProps {
  projectId?: string | null;
  serviceStatus: ServiceStatus;
}

interface InsightsAnalyticsState {
  summary: AnalyticsSummary | null;
  scenes: SceneMetric[];
  loading: boolean;
  error: string | null;
}

const ANALYTICS_SCENE_LIMIT = 3;

const formatRatio = (value: number): string => `${(value * 100).toFixed(0)}%`;

export function InsightsAnalytics({ projectId, serviceStatus }: InsightsAnalyticsProps): JSX.Element {
  const [state, setState] = useState<InsightsAnalyticsState>({
    summary: null,
    scenes: [],
    loading: false,
    error: null,
  });

  useEffect(() => {
    if (!projectId) {
      setState({ summary: null, scenes: [], loading: false, error: null });
      return;
    }
    const services = window.services;
    if (!services?.getAnalyticsSummary || !services?.getAnalyticsScenes) {
      setState({
        summary: null,
        scenes: [],
        loading: false,
        error: 'Story Insights bridge unavailable.',
      });
      return;
    }
    let cancelled = false;
    setState((prev) => ({ ...prev, loading: true, error: null }));
    Promise.all([
      services.getAnalyticsSummary({ projectId }),
      services.getAnalyticsScenes({ projectId }),
    ])
      .then(([summaryResp, scenesResp]) => {
        if (cancelled) {
          return;
        }
        if (!summaryResp.ok || !scenesResp.ok) {
          throw new Error(summaryResp.error?.message ?? scenesResp.error?.message ?? 'Failed to load analytics.');
        }
        setState({
          summary: summaryResp.data,
          scenes: scenesResp.data.scenes,
          loading: false,
          error: null,
        });
      })
      .catch((error) => {
        if (cancelled) {
          return;
        }
        setState({
          summary: null,
          scenes: [],
          loading: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      });
    return () => {
      cancelled = true;
    };
  }, [projectId]);

  const limitedScenes = state.scenes.slice(0, ANALYTICS_SCENE_LIMIT);

  return (
    <section className="companion-overlay__section companion-overlay__section--analytics">
      <header className="companion-overlay__section-header">
        <h3>Local analytics</h3>
        <span>{state.summary?.scenes ?? 0} scenes</span>
      </header>
      {state.error && (
        <p className="companion-overlay__error" data-testid="insights-analytics-error">
          {state.error}
        </p>
      )}
      {state.loading && (
        <p className="companion-overlay__placeholder" data-testid="insights-analytics-loading">
          Loading analytics…
        </p>
      )}
      {state.summary && (
        <div className="companion-overlay__analytics-summary" data-testid="insights-analytics-summary">
          <div>
            <strong>Word count</strong>
            <span>{state.summary.wordCount}</span>
          </div>
          <div>
            <strong>Avg. readability</strong>
            <span>{state.summary.avgReadability !== null ? state.summary.avgReadability.toFixed(1) : '-'}</span>
          </div>
          <div>
            <strong>Project</strong>
            <span>{state.summary.projectId}</span>
          </div>
        </div>
      )}
      {limitedScenes.length > 0 && (
        <div className="companion-overlay__analytics-scenes" data-testid="insights-analytics-scenes">
          {limitedScenes.map((scene) => (
            <div key={scene.sceneId} className="companion-overlay__analytics-scene">
              <strong>{scene.title ?? scene.sceneId}</strong>
              <p>
                Words: {scene.wordCount} · Readability:{' '}
                {scene.readability !== null ? scene.readability.toFixed(1) : '-'}
              </p>
              <p>
                Dialogue: {formatRatio(scene.density.dialogueRatio)} · Narration:{' '}
                {formatRatio(scene.density.narrationRatio)}
              </p>
            </div>
          ))}
        </div>
      )}
      {serviceStatus !== 'online' && (
        <p className="companion-overlay__placeholder" data-testid="insights-analytics-offline">
          Story Insights require services; reconnect to refresh the latest data.
        </p>
      )}
    </section>
  );
}

function formatWordCount(value: number): string {
  return value.toLocaleString();
}

function formatPercentage(value: number): string {
  if (!Number.isFinite(value) || value <= 0) {
    return '0%';
  }
  const ratio = Math.max(0, Math.min(1, value));
  return `${Math.round(ratio * 100)}%`;
}

function describeEmotionPoint(point: EmotionArcPoint | null): string {
  if (!point) {
    return 'No neighbouring scenes tagged yet.';
  }
  const tagLabel = point.emotionTag ?? 'untagged';
  return `${point.order}. ${point.title} — ${tagLabel} (${formatIntensity(point.intensity)})`;
}

function describePaceHighlights(metrics: ScenePacingMetric[]): string {
  if (metrics.length === 0) {
    return 'None flagged';
  }
  return metrics
    .map((metric) => `${metric.title} (${formatWordCount(metric.wordCount)} words)`)
    .join(', ');
}

export default function CompanionOverlay({
  open,
  onClose,
  activeScene,
  activeDraft,
  project,
  drafts,
  rubric,
  onRubricChange,
  builtInRubric,
  scenes,
  activeSceneId,
  batchState,
  onBatchCritique,
  serviceStatus,
}: CompanionOverlayProps): JSX.Element | null {
  const closeButtonRef = useRef<HTMLButtonElement | null>(null);
  const [newCategory, setNewCategory] = useState('');
  const [rubricError, setRubricError] = useState<string | null>(null);
  const [selectedScenes, setSelectedScenes] = useState<string[]>([]);
  const [localRunCount, setLocalRunCount] = useState(0);
  const [queuedModelRuns, setQueuedModelRuns] = useState(0);
  const [modelResumedCount, setModelResumedCount] = useState(0);
  const prevServiceStatusRef = useRef<ServiceStatus>(serviceStatus);

  useEffect(() => {
    if (!open) {
      setNewCategory('');
      setRubricError(null);
      setSelectedScenes([]);
      return;
    }

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        onClose();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    const nextFrame = window.requestAnimationFrame(() => {
      closeButtonRef.current?.focus();
    });

    return () => {
      window.cancelAnimationFrame(nextFrame);
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [open, onClose]);

  useEffect(() => {
    if (!open || !activeSceneId) {
      return;
    }
    setSelectedScenes((current) => {
      if (current.length > 0) {
        return current;
      }
      return [activeSceneId];
    });
  }, [activeSceneId, open]);

  useEffect(() => {
    if (!open) {
      return;
    }
    setSelectedScenes((current) => {
      const availableIds = scenes.map((scene) => scene.id);
      const filtered = current.filter((sceneId) => availableIds.includes(sceneId));
      if (filtered.length > 0) {
        return filtered;
      }
      const fallback = activeSceneId && availableIds.includes(activeSceneId)
        ? activeSceneId
        : availableIds[0] ?? null;
      return fallback ? [fallback] : [];
    });
  }, [activeSceneId, open, scenes]);

  const analyticsConfig = useMemo(
    () =>
      resolveAnalyticsConfig(
        typeof window !== 'undefined' ? window.runtimeConfig?.analytics ?? null : null,
      ),
    [],
  );

  const emotionArc = useMemo(
    () => computeEmotionArc(scenes, analyticsConfig),
    [analyticsConfig, scenes],
  );

  const pacingProfile = useMemo(
    () => computePacingProfile(scenes, drafts, analyticsConfig),
    [analyticsConfig, drafts, scenes],
  );

  const emotionContext = useMemo(() => {
    if (emotionArc.length === 0) {
      return { active: null, previous: null, next: null, taggedCount: 0, ratio: 0 };
    }
    let index = -1;
    if (activeScene?.id) {
      index = emotionArc.findIndex((point) => point.sceneId === activeScene.id);
    }
    if (index < 0) {
      index = 0;
    }
    const activePoint = emotionArc[index] ?? null;
    const previousPoint = index > 0 ? emotionArc[index - 1] : null;
    const nextPoint = index >= 0 && index < emotionArc.length - 1 ? emotionArc[index + 1] : null;
    const taggedCount = emotionArc.reduce(
      (total, point) => (point.emotionTag ? total + 1 : total),
      0,
    );
    const ratio = emotionArc.length > 0 ? taggedCount / emotionArc.length : 0;
    return {
      active: activePoint,
      previous: previousPoint,
      next: nextPoint,
      taggedCount,
      ratio,
    };
  }, [activeScene?.id, emotionArc]);

  const pacingContext = useMemo(() => {
    const metrics = pacingProfile.sceneMetrics;
    if (metrics.length === 0) {
      return {
        active: null,
        slowHighlights: [] as ScenePacingMetric[],
        fastHighlights: [] as ScenePacingMetric[],
      };
    }
    let activeMetric: ScenePacingMetric | null = metrics[0] ?? null;
    if (activeScene?.id) {
      const match = metrics.find((metric) => metric.sceneId === activeScene.id);
      if (match) {
        activeMetric = match;
      }
    }
    const slowHighlights = metrics
      .filter((metric) => metric.paceLabel === 'slow' && metric.sceneId !== activeMetric?.sceneId)
      .slice()
      .sort((left, right) => right.wordCount - left.wordCount)
      .slice(0, 2);
    const fastHighlights = metrics
      .filter((metric) => metric.paceLabel === 'fast' && metric.sceneId !== activeMetric?.sceneId)
      .slice()
      .sort((left, right) => left.wordCount - right.wordCount)
      .slice(0, 2);
    return {
      active: activeMetric,
      slowHighlights,
      fastHighlights,
    };
  }, [activeScene?.id, pacingProfile]);

  const sceneMeta = useMemo(() => {
    if (!project || !activeScene) {
      return null;
    }
    return project.scenes.find((scene) => scene.id === activeScene.id) ?? null;
  }, [project, activeScene]);

  const analysis = useMemo(() => analyseDraft(activeDraft), [activeDraft]);
  const localInsights = useMemo(
    () => buildInsights(analysis, sceneMeta, activeDraft.trim().length === 0),
    [analysis, sceneMeta, activeDraft],
  );
  const modelInsights = useMemo(
    () => buildModelInsights(analysis, sceneMeta),
    [analysis, sceneMeta],
  );

  const stats: SceneInsight[] = useMemo(() => {
    const items: SceneInsight[] = [
      { label: 'Word count', value: analysis.wordCount.toLocaleString() },
      {
        label: 'Avg sentence length',
        value: analysis.sentenceAverage > 0 ? `${analysis.sentenceAverage.toFixed(1)} words` : '—',
      },
      {
        label: 'Paragraphs',
        value: analysis.paragraphCount.toString(),
      },
    ];
    if (analysis.longestSentenceLength > 0) {
      items.push({
        label: 'Longest sentence',
        value: `${analysis.longestSentenceLength} words`,
      });
    }
    if (sceneMeta?.word_target) {
      items.push({
        label: 'Target',
        value: `${sceneMeta.word_target.toLocaleString()} words`,
      });
    }
    if (sceneMeta?.emotion_tag) {
      items.push({
        label: 'Emotion tag',
        value: sceneMeta.emotion_tag,
      });
    }
    if (sceneMeta?.purpose) {
      items.push({
        label: 'Scene purpose',
        value: sceneMeta.purpose,
      });
    }
    return items;
  }, [analysis, sceneMeta]);

  const sortedScenes = useMemo(
    () => [...scenes].sort((left, right) => left.order - right.order),
    [scenes],
  );

  const selectionSet = useMemo(() => new Set(selectedScenes), [selectedScenes]);
  const disableBatchRun = batchState.running || selectedScenes.length === 0;
  const runAllDisabled = !activeScene;
  const offlineRunHint = useMemo(() => {
    if (serviceStatus !== 'online' && queuedModelRuns > 0) {
      return `${localRunCount} Local Ran · ${queuedModelRuns} Will Resume When Online.`;
    }
    return null;
  }, [localRunCount, queuedModelRuns, serviceStatus]);

  const handleRemoveCategory = useCallback(
    (category: string) => {
      onRubricChange(rubric.filter((entry) => entry !== category));
    },
    [onRubricChange, rubric],
  );

  const quickAddOptions = useMemo(
    () =>
      builtInRubric.filter(
        (entry) => !rubric.some((item) => item.toLowerCase() === entry.toLowerCase()),
      ),
    [builtInRubric, rubric],
  );

  const handleToggleScene = useCallback((sceneId: string) => {
    setSelectedScenes((previous) =>
      previous.includes(sceneId)
        ? previous.filter((id) => id !== sceneId)
        : [...previous, sceneId],
    );
  }, []);

  const handleSelectAll = useCallback(() => {
    setSelectedScenes(sortedScenes.map((scene) => scene.id));
  }, [sortedScenes]);

  const handleClearSelection = useCallback(() => {
    setSelectedScenes([]);
  }, []);

  const handleRunBatch = useCallback(() => {
    if (batchState.running) {
      return;
    }
    onBatchCritique(selectedScenes);
  }, [batchState.running, onBatchCritique, selectedScenes]);

  const runLocalInsights = useCallback(() => {
    setLocalRunCount((previous) => previous + 1);
    recordDebugEvent('insights.local_ran', {
      sceneId: activeScene?.id ?? null,
    });
  }, [activeScene?.id]);

  const queueModelInsightsForLater = useCallback(() => {
    setQueuedModelRuns((previous) => previous + 1);
    recordDebugEvent('insights.model_queued_offline', {
      sceneId: activeScene?.id ?? null,
    });
  }, [activeScene?.id]);

  const handleRunAllInsights = useCallback(() => {
    runLocalInsights();
    if (serviceStatus === 'online') {
      recordDebugEvent('insights.model_run_online', {
        sceneId: activeScene?.id ?? null,
      });
      return;
    }
    queueModelInsightsForLater();
  }, [activeScene?.id, queueModelInsightsForLater, runLocalInsights, serviceStatus]);

  const handleAddCategory = useCallback(() => {
    const trimmed = newCategory.trim();
    if (!trimmed) {
      setRubricError('Enter a category name to add.');
      return;
    }
    if (trimmed.length > MAX_RUBRIC_LENGTH) {
      setRubricError(`Categories must be ${MAX_RUBRIC_LENGTH} characters or fewer.`);
      return;
    }
    if (!RUBRIC_PATTERN.test(trimmed)) {
      setRubricError('Only letters, numbers, spaces, and basic punctuation (- . , & : / \') are allowed.');
      return;
    }
    const normalised = trimmed.replace(/\s+/g, ' ');
    if (rubric.some((entry) => entry.toLowerCase() === normalised.toLowerCase())) {
      setRubricError('Category already exists in the rubric.');
      return;
    }
    onRubricChange([...rubric, normalised]);
    setNewCategory('');
    setRubricError(null);
  }, [newCategory, onRubricChange, rubric]);

  const handleQuickAdd = useCallback(
    (category: string) => {
      if (rubric.some((entry) => entry.toLowerCase() === category.toLowerCase())) {
        return;
      }
      onRubricChange([...rubric, category]);
    },
    [onRubricChange, rubric],
  );

  const handleReset = useCallback(() => {
    onRubricChange([...builtInRubric]);
    setRubricError(null);
  }, [builtInRubric, onRubricChange]);

  useEffect(() => {
    const previousStatus = prevServiceStatusRef.current;
    if (serviceStatus !== 'online') {
      setModelResumedCount(0);
    }
    if (previousStatus !== 'online' && serviceStatus === 'online' && queuedModelRuns > 0) {
      setModelResumedCount(queuedModelRuns);
      recordDebugEvent('insights.model_ran_after_reconnect', {
        sceneId: activeScene?.id ?? null,
        count: queuedModelRuns,
      });
      setQueuedModelRuns(0);
    }
    prevServiceStatusRef.current = serviceStatus;
  }, [serviceStatus, queuedModelRuns, activeScene?.id]);

  if (!open) {
    return null;
  }

  return (
    <div
      className="companion-overlay"
      role="dialog"
      aria-modal="true"
      aria-label="Companion overlay"
      data-testid="companion-overlay"
    >
      <div className="companion-overlay__panel">
        <header className="companion-overlay__header">
          <div>
            <h2>Companion</h2>
            <p>Guidance and pacing feedback for your current scene.</p>
          </div>
          <button
            ref={closeButtonRef}
            type="button"
            className="companion-overlay__close"
            onClick={onClose}
          >
            Close
          </button>
        </header>

      <div className="companion-overlay__content">
        {serviceStatus !== 'online' ? (
          <div className="companion-overlay__offline-banner" role="status" aria-live="polite">
            Local Only — Model Insights Paused.
          </div>
        ) : null}
          <section className="companion-overlay__section">
            <header className="companion-overlay__section-header" data-testid="insights-toolbar">
              <div className="companion-overlay__section-heading">
                <h3>Scene Insights</h3>
                {activeScene ? <span>{activeScene.id}</span> : null}
              </div>
              <button
                type="button"
                className="companion-overlay__run-all"
                onClick={handleRunAllInsights}
                disabled={runAllDisabled}
                title={runAllDisabled ? 'Select A Scene To Run Insights.' : undefined}
              >
                Run All Insights
              </button>
            </header>
            {offlineRunHint ? (
              <>
                <p className="companion-overlay__run-hint">{offlineRunHint}</p>
                <div className="companion-overlay__run-hint companion-overlay__run-hint--status">
                  <span data-testid="insights-local-ran">
                    {localRunCount} Local insights ran
                  </span>
                  <span data-testid="insights-model-queued">
                    {queuedModelRuns} model insights queued
                  </span>
                </div>
              </>
            ) : null}
            {modelResumedCount > 0 ? (
              <div
                className="companion-overlay__run-hint companion-overlay__run-hint--resumed"
                data-testid="insights-model-resumed"
              >
                {modelResumedCount === 1
                  ? 'Queued model insight resumed'
                  : `Queued ${modelResumedCount} model insights resumed`}
              </div>
            ) : null}
            {activeScene ? (
              <>
                <p className="companion-overlay__scene-title">
                  {activeScene.title ?? 'Untitled scene'}
                </p>
                <dl className="companion-overlay__stats">
                  {stats.map((item) => (
                    <div key={item.label}>
                      <dt>{item.label}</dt>
                      <dd>{item.value}</dd>
                    </div>
                  ))}
                </dl>
                <div className="companion-overlay__analytics">
                  <div className="companion-overlay__analytics-card">
                    <h4>Emotion arc</h4>
                    {emotionArc.length > 0 ? (
                      <>
                        <p className="companion-overlay__analytics-summary">
                          {emotionContext.active
                            ? `Arc position: ${emotionContext.active.emotionTag ?? 'untagged'} (${formatIntensity(emotionContext.active.intensity)}).`
                            : 'Select a scene to chart its arc position.'}
                        </p>
                        <ul className="companion-overlay__analytics-list">
                          <li>
                            {emotionContext.previous
                              ? `Previous: ${describeEmotionPoint(emotionContext.previous)}`
                              : 'Arc starts here.'}
                          </li>
                          <li>
                            {emotionContext.next
                              ? `Next: ${describeEmotionPoint(emotionContext.next)}`
                              : 'Tag the next scene to extend the arc.'}
                          </li>
                        </ul>
                        <p className="companion-overlay__analytics-footnote">
                          Tagged scenes: {emotionContext.taggedCount}/{emotionArc.length}
                          {emotionArc.length > 0 ? ` (${formatPercentage(emotionContext.ratio)})` : null}
                        </p>
                      </>
                    ) : (
                      <p className="companion-overlay__placeholder">
                        Tag scenes with emotions to build the arc summary.
                      </p>
                    )}
                  </div>
                  <div className="companion-overlay__analytics-card">
                    <h4>Pacing</h4>
                    {pacingProfile.sceneMetrics.length > 0 ? (
                      <>
                        <p className="companion-overlay__analytics-summary">
                          {pacingContext.active
                            ? `Current pace: ${pacingContext.active.paceLabel} at ${formatWordCount(pacingContext.active.wordCount)} words${pacingContext.active.wordsPerBeat ? ` (${pacingContext.active.wordsPerBeat} words/beat)` : ''}.`
                            : 'Select a scene to see pacing metrics.'}
                        </p>
                        <dl className="companion-overlay__analytics-stats">
                          <div>
                            <dt>Average</dt>
                            <dd>{`${formatWordCount(Math.round(pacingProfile.averageWordCount))} words`}</dd>
                          </div>
                          <div>
                            <dt>Median</dt>
                            <dd>{`${formatWordCount(Math.round(pacingProfile.medianWordCount))} words`}</dd>
                          </div>
                          <div>
                            <dt>Std dev</dt>
                            <dd>{`${formatWordCount(Math.round(pacingProfile.standardDeviationWordCount))} words`}</dd>
                          </div>
                        </dl>
                        <ul className="companion-overlay__analytics-list">
                          <li>
                            Slow beats:{' '}
                            {pacingContext.slowHighlights.length > 0
                              ? describePaceHighlights(pacingContext.slowHighlights)
                              : 'None flagged'}
                          </li>
                          <li>
                            Fast beats:{' '}
                            {pacingContext.fastHighlights.length > 0
                              ? describePaceHighlights(pacingContext.fastHighlights)
                              : 'None flagged'}
                          </li>
                        </ul>
                      </>
                    ) : (
                      <p className="companion-overlay__placeholder">
                        Add draft text to measure pacing.
                      </p>
                    )}
                  </div>
                </div>
                <InsightsAnalytics
                  projectId={project?.projectId ?? null}
                  serviceStatus={serviceStatus}
                />
                <ul className="companion-overlay__insights">
                  {localInsights.map((suggestion) => (
                    <li key={suggestion}>{suggestion}</li>
                  ))}
                  {localInsights.length === 0 ? (
                    <li>Scene metrics look healthy. Iterate or expand before running a critique.</li>
                  ) : null}
                </ul>
                <div className="companion-overlay__model-insights">
                  <div className="companion-overlay__model-insights-header">
                    <h4>Model Insights</h4>
                    <p className="companion-overlay__model-insights-subhead">
                      {serviceStatus === 'online'
                        ? 'Model-Backed Guidance Is Ready.'
                        : 'Model Insights Require Writing Tools.'}
                    </p>
                  </div>
                  <ul className="companion-overlay__model-insights-list">
                    {modelInsights.map((entry) => (
                      <li
                        key={entry.id}
                        className={`companion-overlay__model-insight${
                          serviceStatus === 'online' ? '' : ' companion-overlay__model-insight--disabled'
                        }`}
                        title={
                          serviceStatus === 'online'
                            ? 'Model Insights Are Ready.'
                            : 'Needs The Model. Reconnect To Run.'
                        }
                        aria-disabled={serviceStatus !== 'online'}
                      >
                        <div>
                          <strong>{entry.title}</strong>
                          <p>{entry.detail}</p>
                        </div>
                        <span className="companion-overlay__model-insight-state">
                          {serviceStatus === 'online' ? 'Model Ready' : 'Model Offline'}
                        </span>
                      </li>
                    ))}
                  </ul>
                </div>
                {analysis.longestSentenceLength > 28 && analysis.longestSentence ? (
                  <blockquote className="companion-overlay__highlight">
                    <strong>Longest sentence snapshot:</strong>
                    <span>{analysis.longestSentence}</span>
                  </blockquote>
                ) : null}
              </>
            ) : (
              <p className="companion-overlay__placeholder">
                Load and select a scene to view pacing and rubric recommendations.
              </p>
            )}
          </section>

          <section className="companion-overlay__section companion-overlay__section--rubric">
            <header className="companion-overlay__section-header">
            <h3>Focus points</h3>
              <span>{rubric.length}</span>
            </header>
            {rubric.length > 0 ? (
              <ul className="companion-overlay__chips">
                {rubric.map((category) => (
                  <li key={category}>
                    <span>{category}</span>
                    <button
                      type="button"
                      aria-label={`Remove ${category}`}
                      onClick={() => handleRemoveCategory(category)}
                    >
                      &times;
                    </button>
                  </li>
                ))}
              </ul>
            ) : (
              <p className="companion-overlay__placeholder">
                Add one or more rubric categories to drive critiques.
              </p>
            )}

            <div className="companion-overlay__form">
              <label htmlFor="companion-rubric-input">Add category</label>
              <div className="companion-overlay__input-row">
                <input
                  id="companion-rubric-input"
                  type="text"
                  value={newCategory}
                  maxLength={MAX_RUBRIC_LENGTH}
                  onChange={(event) => {
                    setNewCategory(event.target.value);
                    if (rubricError) {
                      setRubricError(null);
                    }
                  }}
                  aria-describedby={rubricError ? 'companion-rubric-error' : undefined}
                />
                <button type="button" onClick={handleAddCategory}>
                  Add
                </button>
                <button type="button" onClick={handleReset}>
                  Reset defaults
                </button>
              </div>
              {rubricError ? (
                <p
                  id="companion-rubric-error"
                  className="companion-overlay__error"
                  aria-live="polite"
                >
                  {rubricError}
                </p>
              ) : null}
            </div>

            {quickAddOptions.length > 0 ? (
              <div className="companion-overlay__quick-add">
                <span>Quick add</span>
                <div className="companion-overlay__quick-add-buttons">
                  {quickAddOptions.map((category) => (
                    <button
                      key={category}
                      type="button"
                      onClick={() => handleQuickAdd(category)}
                    >
                      {category}
                    </button>
                  ))}
                </div>
              </div>
            ) : null}
          </section>
          <section className="companion-overlay__section companion-overlay__section--batch">
            <header className="companion-overlay__section-header">
              <h3>Scene reviews</h3>
              <span>{selectedScenes.length}</span>
            </header>
            {sortedScenes.length === 0 ? (
              <p className="companion-overlay__placeholder">
                Load a project with scenes to run batch critiques.
              </p>
            ) : (
              <>
                <ul className="companion-overlay__batch-list">
                  {sortedScenes.map((scene) => {
                    const result = batchState.results[scene.id];
                    const status = result?.status ?? 'idle';
                    const isSelected = selectionSet.has(scene.id);
                    return (
                      <li
                        key={scene.id}
                        className={`companion-overlay__batch-item companion-overlay__batch-item--${status}`}
                      >
                        <label>
                          <input
                            type="checkbox"
                            checked={isSelected}
                            disabled={batchState.running}
                            onChange={() => handleToggleScene(scene.id)}
                            aria-label={`Select ${scene.title ?? scene.id}`}
                          />
                          <span>
                            <strong>{scene.title}</strong>
                            <em>
                              {scene.id} · #{scene.order}
                            </em>
                          </span>
                        </label>
                        <span
                          className={`companion-overlay__batch-status companion-overlay__batch-status--${status}`}
                        >
                          {statusLabel(status)}
                        </span>
                        {result?.summary ? (
                          <p className="companion-overlay__batch-summary">{result.summary}</p>
                        ) : null}
                        {result?.error ? (
                          <p className="companion-overlay__batch-error">{result.error}</p>
                        ) : null}
                      </li>
                    );
                  })}
                </ul>
                <div className="companion-overlay__batch-actions">
                  <button type="button" onClick={handleSelectAll} disabled={batchState.running}>
                    Select all
                  </button>
                  <button type="button" onClick={handleClearSelection} disabled={batchState.running}>
                    Clear
                  </button>
                  <button type="button" onClick={handleRunBatch} disabled={disableBatchRun}>
                    {batchState.running ? 'Running…' : 'Review selected scenes'}
                  </button>
                </div>
              </>
            )}
          </section>
        </div>
      </div>
    </div>
  );
}
